/* SELECT */

SELECT * FROM EMPLOYEES;

SELECT 100+88 FROM DUAL

SELECT * FROM DUAL

SELECT SYSDATE FROM DUAL

SELECT LAST_NAME,SALARY,JOB_ID 
FROM EMPLOYEES

SELECT LAST_NAME,SALARY,SALARY+5000 AS BONUS,JOB_ID 
FROM EMPLOYEES

SELECT LAST_NAME,SALARY,SALARY+5000 AS MONTHLY_BONUS,JOB_ID 
FROM EMPLOYEES

SELECT LAST_NAME,SALARY,SALARY+5000 "MONTHLY BONUS",JOB_ID 
FROM EMPLOYEES

SELECT LAST_NAME,SALARY,SALARY*12+5000 AS BONUS,JOB_ID 
FROM EMPLOYEES

SELECT LAST_NAME,SALARY,(SALARY+5000)*12 AS BONUS,JOB_ID 
FROM EMPLOYEES

/* NULL */

SELECT LAST_NAME,SALARY,COMMISSION_PCT, COMMISSION_PCT+1000 AS BONUS,JOB_ID 
FROM EMPLOYEES

/* CONCATENATION */

SELECT FIRST_NAME || LAST_NAME FROM EMPLOYEES

SELECT FIRST_NAME ||' is a '|| JOB_ID FROM EMPLOYEES

SELECT DEPARTMENT_ID || q'[ DEPARTMENT'S MANAGER IS: ]' || MANAGER_ID
FROM DEPARTMENTS

SELECT * FROM DEPARTMENTS

SELECT DISTINCT DEPARTMENT_ID FROM EMPLOYEES 

DESCRIBE EMPLOYEES

/* ACTIVITIES */

/* 1) How many unique departments have employees currently working in them?

2)	For employees who quit the organization, find out how many years the employees were employed. 
Assume that the year consists of 365.25 days. 
Also retrieve the EMPLOYEE_ID, JOB_ID, START_DATE, and END_DATE for these employees 

3)	Query the JOBS table and return a single expression of the form The Job Id for the <job_title’s> job is: <job_id>. 
Take note that the job_title should have an apostrophe and an “s” appended to it to read more naturally. 
A sample of this output for the organization president is: “The Job Id for the President’s job is: AD_PRES.” 
Alias this column expression as “Job Description” using the AS keyword.  */

/* Restricting data */

/* WHERE, BETWEEN, LIKE, IN , AND, OR, NOT, NULL */

SELECT EMPLOYEE_ID, LAST_NAME, JOB_ID,DEPARTMENT_ID
FROM EMPLOYEES
WHERE DEPARTMENT_ID=60

SELECT EMPLOYEE_ID, LAST_NAME, JOB_ID,DEPARTMENT_ID
FROM EMPLOYEES
WHERE last_name = 'King'

SELECT EMPLOYEE_ID, LAST_NAME, JOB_ID,DEPARTMENT_ID, HIRE_DATE
FROM EMPLOYEES
WHERE HIRE_DATE >= '21-SEP-05'

SELECT EMPLOYEE_ID, LAST_NAME, JOB_ID,DEPARTMENT_ID, HIRE_DATE
FROM EMPLOYEES
WHERE HIRE_DATE BETWEEN '21-SEP-05' AND '04-JAN-08'

SELECT EMPLOYEE_ID, LAST_NAME, JOB_ID,DEPARTMENT_ID, HIRE_DATE, SALARY+100 AS NEW_SALARY
FROM EMPLOYEES
WHERE HIRE_DATE NOT BETWEEN '21-SEP-05' AND '04-JAN-08'

SELECT EMPLOYEE_ID, LAST_NAME, JOB_ID,DEPARTMENT_ID, SALARY
FROM EMPLOYEES
WHERE SALARY > 15000
AND
DEPARTMENT_ID IN (90,60,100)

SELECT EMPLOYEE_ID, LAST_NAME, JOB_ID,DEPARTMENT_ID, SALARY
FROM EMPLOYEES
WHERE SALARY > 15000
OR
DEPARTMENT_ID IN (90,60,100)

SELECT EMPLOYEE_ID, LAST_NAME, JOB_ID,DEPARTMENT_ID
FROM EMPLOYEES
WHERE JOB_ID LIKE 'S%'

SELECT EMPLOYEE_ID, LAST_NAME, JOB_ID,DEPARTMENT_ID, JOB_ID
FROM EMPLOYEES
WHERE LAST_NAME LIKE '_at%'

SELECT FIRST_NAME, LAST_NAME, MANAGER_ID
FROM EMPLOYEES
WHERE MANAGER_ID IS NULL

SELECT FIRST_NAME, LAST_NAME, JOB_ID, COMMISSION_PCT
FROM EMPLOYEES
WHERE COMMISSION_PCT IS NOT NULL

SELECT LAST_NAME, SALARY, JOB_ID
FROM EMPLOYEES
WHERE JOB_ID = 'SA_REP'
OR JOB_ID = 'AD_PRES'
AND SALARY > 15000

SELECT LAST_NAME, SALARY, JOB_ID
FROM EMPLOYEES
WHERE (JOB_ID = 'SA_REP'
OR JOB_ID = 'AD_PRES')
AND SALARY > 15000

/* ORDER BY */

SELECT LAST_NAME, HIRE_DATE, SALARY
FROM EMPLOYEES
ORDER BY HIRE_DATE

SELECT LAST_NAME, HIRE_DATE, SALARY
FROM EMPLOYEES
ORDER BY HIRE_DATE DESC

SELECT LAST_NAME, HIRE_DATE
FROM EMPLOYEES
ORDER BY SALARY DESC

SELECT LAST_NAME, HIRE_DATE, SALARY
FROM EMPLOYEES
ORDER BY LAST_NAME

SELECT LAST_NAME, HIRE_DATE, SALARY, COMMISSION_PCT
FROM EMPLOYEES
ORDER BY COMMISSION_PCT

SELECT LAST_NAME, HIRE_DATE, SALARY, COMMISSION_PCT
FROM EMPLOYEES
ORDER BY COMMISSION_PCT DESC

SELECT LAST_NAME, HIRE_DATE, SALARY, COMMISSION_PCT, SALARY*0.12 "ANNUAL SAL"
FROM EMPLOYEES
ORDER BY "ANNUAL SAL" DESC

SELECT LAST_NAME, HIRE_DATE, SALARY, COMMISSION_PCT, SALARY*12 "ANNUAL SAL"
FROM EMPLOYEES
ORDER BY 3 DESC

SELECT LAST_NAME,DEPARTMENT_ID, SALARY
FROM EMPLOYEES
ORDER BY DEPARTMENT_ID, SALARY

/* SUBSTITUTION VARIABLES */

SELECT LAST_NAME, EMPLOYEE_ID
FROM EMPLOYEES
WHERE EMPLOYEE_ID = 108

SELECT LAST_NAME, EMPLOYEE_ID
FROM EMPLOYEES
WHERE EMPLOYEE_ID = &EMPLOYEE_NUM

SELECT LAST_NAME, EMPLOYEE_ID, DEPARTMENT_ID
FROM EMPLOYEES
WHERE DEPARTMENT_ID = &&DEPARTMENT_NUM

UNDEFINE DEPARTMENT_NUM
DEFINE DEPARTMENT_NUM = 90

/* ACTIVITIES */
/* 1. RETRIEVE A LIST OF DEPARTMENT NAMES THAT ENDS WITH "ING" AND SECOND CHARACTER IS "A"

2. Write a query that extracts the JOB_TITLE, MIN_SALARY, and MAX_SALARY columns, 
as well as an expression called VARIANCE, which is the difference between the MAX_SALARY and MIN_SALARY values, 
for each row. The result should include only JOB_TITLE values that contain either the word “President” or “Manager.” 
Sort the list in descending order based on the VARIANCE expression. If more than one row has the same VARIANCE value, then, 
sort these rows by JOB_TITLE in reverse alphabetic order. 

3)	A common computation performed by the Finance department relates to the calculation of taxes levied upon an employee. 
The tax deducted per employee is calculated by obtaining the annual salary for the employee and the current tax rate, 
which may vary from year to year as per the regulations laid from the ministry of finance. 
Write a reusable query for the current tax rate and for an employee_id as input, return the EMPLOYEE_ID, 
FIRST_NAME, SALARY, ANNUAL SALARY,TAX_RATE, and the TAX AMOUNT */

/* FUNCTIONS */

/* CHARACTER --> UPPER, LOWER, INITCAP, LENGTH, SUBSTR, TRIM 
NUMERIC --> ROUND, ABS, MOD, TRUNC
DATES --> NEXT_DAY, LAST_DAY, ADD_MONTHS, MONTHS_BETWEEN */

SELECT EMPLOYEE_ID, CONCAT(FIRST_NAME, LAST_NAME) "FULL NAME", JOB_ID, LENGTH(LAST_NAME),
INSTR(LAST_NAME, 'a') "CONTAINS A?", UPPER(LAST_NAME)
FROM EMPLOYEES
WHERE SUBSTR(JOB_ID,4) = 'REP'

SELECT ROUND(108.98765,2)
FROM DUAL

SELECT SALARY, MOD(SALARY,5000)
FROM EMPLOYEES

/* DATES */

/* RR format */
/* YY format */

/* 18-June-19
19-May-78 */

/* 0-49 --> CURRENT CENTURY, 50-99 , LAST CENTURY

DD-MM-RR

1998   05-APR-98 1998  1998
1998   05-APR-22 2022  1921

2018   05-APR-18 2018  2018 
2018   05-APR-98 1998  2098 */

15-09-2022

22 --> RR --> 2022
78 --> RR --> 1978
22 --> YY --> 2022
78 --> YY --> 2078

SELECT SYSDATE FROM DUAL

SELECT EMPLOYEE_ID, ROUND((SYSDATE-HIRE_DATE)/7) WEEKS
FROM EMPLOYEES
ORDER BY WEEKS DESC

SELECT MONTHS_BETWEEN('01-JAN-10','12-DEC-03') FROM DUAL
SELECT NEXT_DAY('29-JAN-24', 'THURSDAY') FROM DUAL
SELECT LAST_DAY('14-SEP-23') FROM DUAL
SELECT ADD_MONTHS('30-SEP-23',2) FROM DUAL
SELECT NEXT_DAY('29-JAN-24', 1) FROM DUAL
SELECT ADD_MONTHS('31-JAN-24',-2) FROM DUAL

SELECT TO_CHAR(SYSDATE, 'DD "OF" MONTH') || ' is my birthday' 
FROM DUAL

SELECT TO_CHAR(SYSDATE, 'DDspth "OF" fmMONTH') || ' is my birthday' 
FROM DUAL

SELECT TO_CHAR(SYSDATE, 'DDth "of" fmMONTH') || ' is my birthday' 
FROM DUAL

SELECT TO_CHAR(SYSDATE, 'DD MM YYYY') || ' is my birthday' 
FROM DUAL

SELECT TO_CHAR(SYSDATE, 'YYYY') || ' is my birthday' 
FROM DUAL

SELECT TO_CHAR(SYSDATE, 'YEAR') || ' is my birthday' 
FROM DUAL

SELECT TO_CHAR(SYSDATE, 'MM') || ' is my birthday' 
FROM DUAL

SELECT FIRST_NAME || ' ' ||  LAST_NAME FROM EMPLOYEES


SELECT TO_CHAR(SALARY, '$99,999.00') SALARY FROM EMPLOYEES

/* ADD_MONTHS, NEXT_DAY, LAST_DAY */

/* 
1. Print the hire date in the format "01-Jan-2022"
2. Print last name, hire date in the format, "1st of jan 2022" */


/* 1. Envelope printing restricts the addressee field to 16 characters. Ideally, 
the addressee field contains employees’ FIRST_NAME and LAST_NAME values separated by a 
single space. When the combined length of an employee’s FIRST_NAME and LAST_NAME exceeds 15 characters, 
the addressee field should contain their formal name. An employee’s formal name is made up of the 
first letter of their FIRST_NAME and the first 14 characters of their LAST_NAME. You are required to retrieve 
a list of FIRST_NAME and LAST_NAME values and formal names for employees where the combined length of FIRST_NAME 
and LAST_NAME exceeds 15 characters. 

2. Write a Query that displays the employee number, hire date, number of months employed, six-month review date, 
first Friday after hire date, and the last day of the hire month for all employees 
who have been employed for fewer than 150 months and working for department 50  */

/* NVL,  NVL2, COALESCE, NULL IF */

SELECT LAST_NAME, SALARY, COMMISSION_PCT, NVL(COMMISSION_PCT, SALARY)
FROM EMPLOYEES

SELECT LAST_NAME, SALARY, COMMISSION_PCT, NVL2(COMMISSION_PCT, 'SAL+COMM', 'NO COMMISSION') AS "BONUS"
FROM EMPLOYEES

SELECT FIRST_NAME, LAST_NAME, NULLIF(LENGTH(FIRST_NAME),LENGTH(LAST_NAME)) RESULT 
FROM EMPLOYEES

SELECT LAST_NAME, COMMISSION_PCT, MANAGER_ID, COALESCE(TO_CHAR(COMMISSION_PCT), TO_CHAR(MANAGER_ID),'NO COMMISSION AND NO MANAGER')
FROM EMPLOYEES

/* CASE & DECODE FUNCTION */

SELECT LAST_NAME, JOB_ID, SALARY,
CASE JOB_ID WHEN 'IT_PROG' THEN SALARY*0.10
WHEN 'ST_CLERK' THEN SALARY*0.05
WHEN 'SA_REP' THEN SALARY*0.2
ELSE SALARY END "REVISED_SALARY"
FROM EMPLOYEES

SELECT LAST_NAME, JOB_ID, SALARY,
DECODE(JOB_ID,'IT_PROG',SALARY*0.10,
'ST_CLERK',SALARY*0.05,
'SA_REP',SALARY*0.2,
SALARY) "REVISED_SALARY"
FROM EMPLOYEES

SELECT SALARY, LAST_NAME,
(CASE WHEN SALARY<=10000 THEN 'LOW'
WHEN SALARY BETWEEN 10000 AND 20000 THEN 'AVG'
WHEN SALARY>=20000 THEN 'HIGH'
ELSE 'UNKNOWN' END) SALARY
FROM EMPLOYEES

/* GROUP & AGGREGATION FUNCTIONS */
/* GROUP FUNCTIONS IGNORES NULL VALUES */
/* AVG, COUNT, DISTINCT, SUM, MIN, MAX */

Select Round(Avg(Salary)), Max(Salary), Min(Salary), 
From Employees
Where Job_Id Like '%REP%'

Select Min(Hire_Date), Max(Hire_Date)
From Employees

Select Count(*)
From Employees
Where Department_Id = 80

Select Count(Commission_Pct)
From Employees
Where Department_Id = 80

Select * From Employees
Where Department_Id = 100

Select Avg(Commission_Pct)
From Employees

Select Avg(Nvl(Commission_Pct,0))
From Employees

Select Count(Distinct Department_Id)
From Employees

SELECT DISTINCT DEPARTMENT_ID
FROM EMPLOYEES

SELECT COUNT(COMMISSION_PCT)
FROM EMPLOYEES

SELECT DEPARTMENT_ID, AVG(SALARY), MIN(SALARY), MAX(SALARY)
FROM EMPLOYEES
GROUP BY(DEPARTMENT_ID)
ORDER BY MAX(SALARY) DESC

SELECT AVG(SALARY), MIN(SALARY), MAX(SALARY)
FROM EMPLOYEES
GROUP BY(DEPARTMENT_ID)
ORDER BY MAX(SALARY) DESC

SELECT DEPARTMENT_ID, AVG(SALARY), MIN(SALARY), MAX(SALARY)
FROM EMPLOYEES
WHERE JOB_ID IN ('AD_VP','AD_PRES','IT_PROG')
GROUP BY(DEPARTMENT_ID)
ORDER BY MAX(SALARY) DESC


/* illegal */
SELECT DEPARTMENT_ID, AVG(SALARY), MIN(SALARY), MAX(SALARY)
FROM EMPLOYEES
WHERE AVG(SALARY)>10000
GROUP BY(DEPARTMENT_ID)
ORDER BY MAX(SALARY) DESC

SELECT DEPARTMENT_ID, JOB_ID, ROUND(AVG(SALARY),2), MIN(SALARY), MAX(SALARY)
FROM EMPLOYEES
WHERE JOB_ID IN ('AD_VP','AD_PRES','IT_PROG')
GROUP BY(DEPARTMENT_ID, JOB_ID)
HAVING AVG(SALARY)>10000
ORDER BY MAX(SALARY) DESC

select * from employees
where rownum <=10

select * from employees
fetch first 10 rows only

select salary, department_id, sum(salary) over() as "ctc"
from employees

/* ACTIVITIES 

1)	The company is planning a recruitment drive and wants to identify the days of the week on which 2  or more staff members were hired. 
Your report must list the days and the number of employees hired on each of them.

2) Analysis of staff turnover is a common reporting requirement. You are required to create a report containing the number of 
employees who left their jobs, grouped by the year in which they left. The jobs they performed are also required. 
The results must be sorted in descending order based on the number of employees in each group.
The report must list the year, the JOB_ID, and the number of employees who left a particular job in that year.

3) Calculate the average length of all the country names. Any fractional components must be rounded to the nearest whole number. */

/* JOINS & SUBQUERIES */

/* PURE NATURAL JOINS, USING CLAUSE, ON, OUTER JOINS */

select * from LOCATIONS
select * from DEPARTMENTS

SELECT DEPARTMENT_ID, DEPARTMENT_NAME, LOCATION_ID, CITY
FROM DEPARTMENTS
NATURAL JOIN LOCATIONS

SELECT DEPARTMENT_ID, DEPARTMENT_NAME, D.LOCATION_ID, CITY
FROM DEPARTMENTS D,LOCATIONS L
WHERE (D.LOCATION_ID = L.LOCATION_ID)

SELECT DEPARTMENT_ID, DEPARTMENT_NAME, D.LOCATION_ID, CITY
FROM DEPARTMENTS D,LOCATIONS L
WHERE DEPARTMENT_ID IN (60,90,100)

/* USING CLAUSE */

SELECT * 
FROM EMPLOYEES 
JOIN DEPARTMENTS
USING (DEPARTMENT_ID)
WHERE DEPARTMENT_ID = 80

/* COMMON COLUMNS THAT ARE NOT USED IN THE "USING" CLAUSE MUST BE ALIASED */

SELECT LAST_NAME, DEPARTMENT_ID, D.MANAGER_ID
FROM EMPLOYEES E
JOIN DEPARTMENTS D
USING (DEPARTMENT_ID)
WHERE DEPARTMENT_ID = 80

/* DO NOT ALIAS THE COLUMN USED IN THE USING CLAUSE */

SELECT LAST_NAME, DEPARTMENT_ID, E.MANAGER_ID
FROM EMPLOYEES E
JOIN DEPARTMENTS D
USING (DEPARTMENT_ID)
WHERE D.DEPARTMENT_ID = 80

CREATE TABLE a1(CUST_ID NUMBER(10) CONSTRAINT a_PK PRIMARY KEY, CUST_NAME VARCHAR2 (10) NOT NULL, CITY_id number(10))

CREATE TABLE b2(CITY_id number(10) CONSTRAINT b2_PK PRIMARY KEY, cust_id number(10),CITY CHAR(10))

INSERT INTO a1(CUST_ID, CUST_NAME, CITY_id) VALUES (104,'sean',1)
INSERT INTO b2(CITY_id,CUST_ID,CITY ) VALUES (4,102,'MA')

select * from a1
select * from b2

SELECT * FROM a1 natural join b2

SELECT * from a1 a inner join b2 b1 on a.city_id=b1.city_id
SELECT * from a1 a inner join b2 b1 using (city_id)

SELECT * from a1,b2 where a1.city_id=b2.city_id

select * from a1 join b2 using (city_id)

select a.cust_id,city_id, cust_name, city
from a1 a
join b2 b using (city_id)

select b.cust_id,city_id, cust_name, city
from a1 a
join b2 b using (city_id)

select a.cust_id,b.city_id, cust_name, city
from a1 a
inner join b2 b on a.city_id = b.cust_id

/* ON CLAUSE */

SELECT EMPLOYEE_ID, LAST_NAME, E.DEPARTMENT_ID, DEPARTMENT_NAME, LOCATION_ID
FROM EMPLOYEES E
JOIN DEPARTMENTS D
ON (E.DEPARTMENT_ID = D.DEPARTMENT_ID)

SELECT EMPLOYEE_ID, LAST_NAME, E.DEPARTMENT_ID, DEPARTMENT_NAME, L.LOCATION_ID, L.CITY
FROM EMPLOYEES E
JOIN DEPARTMENTS D
ON (E.DEPARTMENT_ID = D.DEPARTMENT_ID)
JOIN LOCATIONS L
ON D.LOCATION_ID = L.LOCATION_ID

SELECT EMPLOYEE_ID, LAST_NAME, E.DEPARTMENT_ID, DEPARTMENT_NAME,LOCATION_ID
FROM EMPLOYEES E
JOIN DEPARTMENTS D
ON (E.DEPARTMENT_ID = D.DEPARTMENT_ID)
WHERE D.DEPARTMENT_ID IN (60,80,90)

SELECT EMPLOYEE_ID, LAST_NAME, E.DEPARTMENT_ID, DEPARTMENT_NAME,LOCATION_ID
FROM EMPLOYEES E
JOIN DEPARTMENTS D
ON (E.DEPARTMENT_ID = D.DEPARTMENT_ID)
AND D.DEPARTMENT_ID IN (60,80,90)


/* USING CLAUSE CAN ONLY BE USED TO JOIN COLUMNS WITH SAME NAMES */
/* IN ON CLAUSE COLUMN NAMES CAN BE DIFFERENT */

/* SELECT A, B, C
FROM T1 JOIN T2
USING (B)

SELECT T1.A, T1.B,T2.C
FROM T T1 JOIN TB T2
ON (T1.B = T2.C) */

SELECT * FROM EMPLOYEES
JOIN DEPARTMENTS
USING (DEPARTMENT_ID)

SELECT * FROM EMPLOYEES E
JOIN DEPARTMENTS D
ON (E.DEPARTMENT_ID=D.DEPARTMENT_ID)

SELECT * FROM EMPLOYEES

/* SELF JOINS */

SELECT E.FIRST_NAME, E.LAST_NAME, MGR.FIRST_NAME, MGR.LAST_NAME
FROM EMPLOYEES E JOIN EMPLOYEES MGR
ON (E.MANAGER_ID = MGR.EMPLOYEE_ID)

/* NON-EQUI JOINS */

SELECT E.LAST_NAME, E.SALARY, J.JOB_TITLE
FROM EMPLOYEES E JOIN JOBS J
ON E.SALARY BETWEEN J.MIN_SALARY AND J.MAX_SALARY

SELECT * FROM JOBS

/* CROSS JOINS */

SELECT EMPLOYEE_ID, DEPARTMENT_NAME
FROM EMPLOYEES
CROSS JOIN DEPARTMENTS

/* OUTER JOINS */

SELECT LAST_NAME, D.DEPARTMENT_ID, DEPARTMENT_NAME
FROM EMPLOYEES E
LEFT OUTER JOIN DEPARTMENTS D
ON (E.DEPARTMENT_ID = D.DEPARTMENT_ID)

SELECT LAST_NAME, D.DEPARTMENT_ID, DEPARTMENT_NAME
FROM EMPLOYEES E
RIGHT OUTER JOIN DEPARTMENTS D
ON (E.DEPARTMENT_ID = D.DEPARTMENT_ID)

SELECT LAST_NAME, D.DEPARTMENT_ID, DEPARTMENT_NAME
FROM EMPLOYEES E
FULL OUTER JOIN DEPARTMENTS D
ON (E.DEPARTMENT_ID = D.DEPARTMENT_ID)

/* 1. Fetch the EMPLOYEE_ID, JOB_ID, DEPARTMENT_ID, LAST_NAME, HIRE_DATE, and END_DATE values for all rows retrieved 
using a pure natural join. Alias the EMPLOYEES table

2. Produce a report with one column aliased as Managers. with each row containing a sentence of the format 
FIRST_NAME LAST_NAME is manager of the DEPARTMENT_NAME

3) you are required to retrieve the DEPARTMENT_NAME and DEPARTMENT_ID values for those departments to which no employees are 
currently assigned

4. You are required to retrieve the employee’s LAST_NAME, EMPLOYEE_ID, manager’s LAST_NAME, and employee’s DEPARTMENT_ID 
for the rows with DEPARMENT_ID values of 10, 20, or 30. Alias the EMPLOYEES table as E and the second instance of the EMPLOYEES 
table as M. Sort the results based on the DEPARTMENT_ID column */










